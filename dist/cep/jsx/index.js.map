{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/ilst/ilst.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.aitools-bolt.cep\",\n  displayName: \"Ai Tools Bolt\",\n  symlink: \"local\",\n  port: 3000,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [{ name: \"ILST\", version: \"[0.0,99.9]\" }],\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 375,\n  height: 650,\n  minWidth: 300,\n  minHeight: 400,\n  maxWidth: 800,\n  maxHeight: 1000,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Ai Tools Bolt\",\n      autoVisible: true,\n    },\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"NC\",\n    org: \"crdev\",\n    password: \"ColorCharlotte2020\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\n","export const currentDocument = (): Document => {\n  return app.activeDocument;\n};\nexport const openDocuments = (): Documents => {\n  return app.documents;\n};\n\nexport const getCurrentLayer = (): Layer => {\n  return app.activeDocument.activeLayer as Layer;\n};\n\nexport const getDocumentWidth = (): number => {\n  return currentDocument().width;\n};\n\nexport const getDocumentHeight = (): number => {\n  return currentDocument().height;\n};\n\nexport const convertToPoints = (value: number, unit: string): number => {\n  var unitValue = UnitValue(`${value} ${unit}`);\n  unitValue.convert(\"pt\");\n  return unitValue.value;\n};\n\nexport function setDocumentColorSpaceRGB() {\n  app.executeMenuCommand(\"doc-color-rgb\");\n}\n\nexport function setDocumentColorSpaceCMYK() {\n  app.executeMenuCommand(\"doc-color-cmyk\");\n}\n\nexport const createColorCMYK = (\n  cyan: number,\n  magenta: number,\n  yellow: number,\n  black: number\n): Color => {\n  var color = new CMYKColor();\n  color.cyan = cyan;\n  color.magenta = magenta;\n  color.yellow = yellow;\n  color.black = black;\n  return color;\n};\n\nexport const createLayer = (name: string): Layer => {\n  var layer = currentDocument().layers.add();\n  layer.name = name;\n  return layer;\n};\n\nexport const getLayerByName = (name: string): Layer | null => {\n  var layer;\n  try {\n    layer = currentDocument().layers.getByName(name);\n  } catch (error) {\n    layer = null;\n  }\n  return layer;\n};\n\nexport function drawEllipse(\n  layerName: string,\n  y: number,\n  x: number,\n  diameter: number,\n  fillColor?: Color,\n  strokeColor?: Color,\n  strokeWidth?: number\n) {\n  var selLayer = getCurrentLayer();\n  var ellipse = selLayer.pathItems.ellipse(y, x, diameter, diameter);\n  fillColor && (ellipse.fillColor = fillColor);\n  strokeColor && (ellipse.strokeColor = strokeColor);\n  strokeWidth && (ellipse.strokeWidth = strokeWidth);\n  return ellipse;\n}\n\nexport function addRegistration(\n  layerName: string,\n  unit: string,\n  diameter: number,\n  edgeOffset: number,\n  marksPrimary: boolean,\n  marksOrientation: boolean,\n  marksOrientationLocation: string,\n  marksCenter: boolean,\n  marksDistance: boolean,\n  marksDistanceValue: number\n) {\n  const doc = currentDocument();\n  const docWidth = doc.width;\n  const docHeight = doc.height;\n  const colorRegistration = createColorCMYK(0, 0, 0, 100);\n  const layer = getLayerByName(layerName) || createLayer(layerName);\n  const diameterPoints = convertToPoints(diameter, unit as UnitName);\n  const halfDiameter = diameterPoints / 2;\n  const edgeOffsetPoints = convertToPoints(edgeOffset, unit as UnitName);\n  const marksDistancePoints = convertToPoints(\n    marksDistanceValue,\n    unit as UnitName\n  );\n\n  doc.rulerOrigin = [0, 0];\n\n  var coordinates: number[][] = [];\n\n  if (marksPrimary) {\n    const coordinatesPrimary: number[][] = [\n      // [ Y, X ]\n      [edgeOffsetPoints + halfDiameter, edgeOffsetPoints - halfDiameter], // Bottom Left\n      [\n        docHeight - edgeOffsetPoints + halfDiameter,\n        edgeOffsetPoints - halfDiameter,\n      ], // Top Left\n      [\n        edgeOffsetPoints + halfDiameter,\n        docWidth - edgeOffsetPoints - halfDiameter,\n      ], // Bottom Right\n      [\n        docHeight - edgeOffsetPoints + halfDiameter,\n        docWidth - edgeOffsetPoints - halfDiameter,\n      ], // Top Right\n    ];\n    coordinates.push(...coordinatesPrimary);\n  }\n\n  if (marksOrientation) {\n    const coordinatesOrientation: number[][] = [];\n    const gap = 144;\n    switch (marksOrientationLocation) {\n      case \"bottom-left\":\n        coordinatesOrientation.push([\n          edgeOffsetPoints + halfDiameter + gap,\n          edgeOffsetPoints - halfDiameter,\n        ]);\n        coordinatesOrientation.push([\n          edgeOffsetPoints + halfDiameter,\n          edgeOffsetPoints - halfDiameter + gap,\n        ]);\n        break;\n      case \"bottom-right\":\n        coordinatesOrientation.push([\n          edgeOffsetPoints + halfDiameter + gap,\n          docWidth - edgeOffsetPoints - halfDiameter,\n        ]);\n        coordinatesOrientation.push([\n          edgeOffsetPoints + halfDiameter,\n          docWidth - edgeOffsetPoints - halfDiameter - gap,\n        ]);\n        break;\n      case \"top-right\":\n        coordinatesOrientation.push([\n          docHeight - edgeOffsetPoints + halfDiameter - gap,\n          docWidth - edgeOffsetPoints - halfDiameter,\n        ]);\n        coordinatesOrientation.push([\n          docHeight - edgeOffsetPoints + halfDiameter,\n          docWidth - edgeOffsetPoints - halfDiameter - gap,\n        ]);\n        break;\n      case \"top-left\":\n      default:\n        coordinatesOrientation.push([\n          docHeight - edgeOffsetPoints + halfDiameter - gap,\n          edgeOffsetPoints - halfDiameter,\n        ]);\n        coordinatesOrientation.push([\n          docHeight - edgeOffsetPoints + halfDiameter,\n          edgeOffsetPoints - halfDiameter + gap,\n        ]);\n        break;\n    }\n\n    coordinates.push(...coordinatesOrientation);\n  }\n\n  if (marksCenter) {\n    const coordinatesCenter: number[][] = [\n      [\n        docHeight - edgeOffsetPoints + halfDiameter,\n        docWidth / 2 - halfDiameter,\n      ], // Top Edge\n      [edgeOffsetPoints + halfDiameter, docWidth / 2 - halfDiameter], // Bottom Edge\n      [docHeight / 2 + halfDiameter, edgeOffsetPoints - halfDiameter], // Left Edge\n      [\n        docHeight / 2 + halfDiameter,\n        docWidth - edgeOffsetPoints - halfDiameter,\n      ], // Right Edge\n    ];\n    coordinates.push(...coordinatesCenter);\n  }\n\n  // Draw each Ellipse from Coordinates\n  for (let index = 0; index < coordinates.length; index++) {\n    const y = coordinates[index][0];\n    const x = coordinates[index][1];\n    drawEllipse(layer.name, y, x, diameterPoints, colorRegistration);\n  }\n  return coordinates;\n}\n","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as ilst from \"./ilst/ilst\";\n\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\n\n// A safe way to get the app name since some versions of Adobe Apps broken BridgeTalk in various places (e.g. After Effects 24-25)\n// in that case we have to do various checks per app to deterimine the app name\n\nconst getAppNameSafely = (): ApplicationName | \"unknown\" => {\n  const compare = (a: string, b: string) => {\n    return a.toLowerCase().indexOf(b.toLowerCase()) > -1;\n  };\n  const exists = (a: any) => typeof a !== \"undefined\";\n  const isBridgeTalkWorking =\n    typeof BridgeTalk !== \"undefined\" &&\n    typeof BridgeTalk.appName !== \"undefined\";\n\n  if (isBridgeTalkWorking) {\n    return BridgeTalk.appName;\n  } else if (app) {\n    //@ts-ignore\n    if (exists(app.name)) {\n      //@ts-ignore\n      const name: string = app.name;\n      if (compare(name, \"photoshop\")) return \"photoshop\";\n      if (compare(name, \"illustrator\")) return \"illustrator\";\n      if (compare(name, \"audition\")) return \"audition\";\n      if (compare(name, \"bridge\")) return \"bridge\";\n      if (compare(name, \"indesign\")) return \"indesign\";\n    }\n    //@ts-ignore\n    if (exists(app.appName)) {\n      //@ts-ignore\n      const appName: string = app.appName;\n      if (compare(appName, \"after effects\")) return \"aftereffects\";\n      if (compare(appName, \"animate\")) return \"animate\";\n    }\n    //@ts-ignore\n    if (exists(app.path)) {\n      //@ts-ignore\n      const path = app.path;\n      if (compare(path, \"premiere\")) return \"premierepro\";\n    }\n    //@ts-ignore\n    if (exists(app.getEncoderHost) && exists(AMEFrontendEvent)) {\n      return \"ame\";\n    }\n  }\n  return \"unknown\";\n};\n\nswitch (getAppNameSafely()) {\n  case \"illustrator\":\n  case \"illustratorbeta\":\n    host[ns] = ilst;\n    break;\n}\n\nexport type Scripts = typeof ilst\n\n// https://extendscript.docsforadobe.dev/interapplication-communication/bridgetalk-class.html?highlight=bridgetalk#appname\ntype ApplicationName =\n  | \"aftereffects\"\n  | \"aftereffectsbeta\"\n  | \"ame\"\n  | \"amebeta\"\n  | \"audition\"\n  | \"auditionbeta\"\n  | \"animate\"\n  | \"animatebeta\"\n  | \"bridge\"\n  | \"bridgebeta\"\n  // | \"flash\"\n  | \"illustrator\"\n  | \"illustratorbeta\"\n  | \"indesign\"\n  | \"indesignbeta\"\n  // | \"indesignserver\"\n  | \"photoshop\"\n  | \"photoshopbeta\"\n  | \"premierepro\"\n  | \"premiereprobeta\";\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","minWidth","minHeight","maxWidth","maxHeight","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyAssets","copyZipAssets","unitValue","app","layer","fillColor","strokeColor","strokeWidth","doc","coordinatesOrientation","drawEllipse","host"],"mappings":";;AAGA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAAUC;AAAcV;AAAsB;AAC9CW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEAC;AAEIC;AACAd;AACAe;AACAC;AACF;AAEFC;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEFQ;AACAC;AACAC;AACF;;AClDA;;ACDA;;AAEA;AACA;;AAEA;AAEA;AACE;AACF;AAEA;AACE;AACF;AAEA;AACE;AACF;AAEA;AACE;AACAC;;AAEF;AAEA;AACEC;AACF;AAEA;AACEA;AACF;AAEA;AAME;;;;;AAKA;AACF;AAEA;;;AAGE;AACF;AAEA;AACE;;;;AAIEC;AACF;AACA;AACF;AAEA;AASE;AACA;AACAC;AACAC;AACAC;AACA;AACF;AAEA;AAYE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAKAC;;AAIA;AACE;AACE;AACA;AAAoE;;AAIjE;;AAIA;AACH;;;AAMJ;AAEA;;;AAGE;AACE;AACEC;AAIAA;AAIA;AACF;AACEA;AAIAA;AAIA;AACF;AACEA;AAIAA;AAIA;AACF;AACA;AACEA;AAIAA;AAIA;AACJ;;AAGF;AAEA;AACE;AAIK;;AAC6D;;AACC;AACjE;;;AAMJ;;AAEA;AACA;;;AAGEC;AACF;AACA;AACF;;;;;;;;;;;;;;;;;;;ACnMA;;AAEA;AACA;;AAEA;;AAEI;;AAEF;;AAAmD;AACnD;AAIA;;;AAGE;AACA;AACE;AACA;;;;;;AAMF;AACA;AACA;AACE;AACA;;;AAGF;AACA;AACA;AACE;AACA;;AAEF;AACA;;AAEE;AACF;AACF;AACA;AACF;AAEA;AACE;AACA;AACEC;AACA;AACJ;;AAIA"}