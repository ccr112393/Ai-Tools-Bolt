{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/ilst/ilst.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.aitools-bolt.cep\",\n  displayName: \"Ai Tools Bolt\",\n  symlink: \"local\",\n  port: 3000,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [{ name: \"ILST\", version: \"[0.0,99.9]\" }],\n  type: \"Panel\",\n  iconDarkNormal: \"./assets/light-icon.png\",\n  iconNormal: \"./assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./assets/light-icon.png\",\n  iconNormalRollOver: \"./assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 375,\n  height: 650,\n  minWidth: 300,\n  minHeight: 400,\n  maxWidth: 800,\n  maxHeight: 1000,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Ai Tools Bolt\",\n      autoVisible: true,\n    },\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"NC\",\n    org: \"crdev\",\n    password: \"ColorCharlotte2020\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [\"assets\"],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\n","export const currentDocument = (): Document => {\n  return app.activeDocument;\n};\nexport const openDocuments = (): Documents => {\n  return app.documents;\n};\n\nexport const getCurrentLayer = (): Layer => {\n  return app.activeDocument.activeLayer as Layer;\n};\n\nexport const getDocumentWidth = (): number => {\n  return currentDocument().width;\n};\n\nexport const getDocumentHeight = (): number => {\n  return currentDocument().height;\n};\n\nexport const convertToPoints = (value: number, unit: string): number => {\n  var unitValue = UnitValue(`${value} ${unit}`);\n  unitValue.convert(\"pt\");\n  return unitValue.value;\n};\n\nexport function setDocumentColorSpaceRGB() {\n  app.executeMenuCommand(\"doc-color-rgb\");\n}\n\nexport function setDocumentColorSpaceCMYK() {\n  app.executeMenuCommand(\"doc-color-cmyk\");\n}\n\nexport const createColorCMYK = (\n  cyan: number,\n  magenta: number,\n  yellow: number,\n  black: number\n): Color => {\n  var color = new CMYKColor();\n  color.cyan = cyan;\n  color.magenta = magenta;\n  color.yellow = yellow;\n  color.black = black;\n  return color;\n};\n\nexport const createLayer = (name: string): Layer => {\n  var layer = currentDocument().layers.add();\n  layer.name = name;\n  return layer;\n};\n\nexport const getLayerByName = (name: string): Layer | undefined => {\n  var layers = currentDocument().layers;\n  for (let index = 0; index < layers.length; index++) {\n    const layer = layers[index];\n    if (layer.name === name) {\n      return layer;\n    }\n  }\n};\n\nexport function drawEllipse(\n  layer: Layer,\n  y: number,\n  x: number,\n  diameter: number,\n  fillColor?: Color,\n  strokeColor?: Color,\n  strokeWidth?: number\n) {\n  var ellipse = layer.pathItems.ellipse(y, x, diameter, diameter);\n  fillColor && (ellipse.fillColor = fillColor);\n  strokeColor && (ellipse.strokeColor = strokeColor);\n  strokeWidth && (ellipse.strokeWidth = strokeWidth);\n  return ellipse;\n}\n\nexport function renameLayers(search: string, replace: string): number {\n  var count = 0;\n  var layers = currentDocument().layers;\n  for (let index = 0; index < layers.length; index++) {\n    const layer = layers[index];\n    if (layer.name.indexOf(search) !== -1) {\n      layer.name = layer.name.replace(search, replace);\n      count++;\n    }\n  }\n  return count;\n}\n\nexport function renamePathItems(search: string, replace: string): number {\n  var count = 0;\n  var items = currentDocument().pathItems;\n  for (let index = 0; index < items.length; index++) {\n    if (items[index].name.indexOf(search) !== -1) {\n      items[index].name = items[index].name.replace(search, replace);\n      count++;\n    }\n  }\n  return count;\n}\n\n// export function renameSelection(search: string, replace: string): number {\n//   var count = 0;\n//   var items = currentDocument().selection;\n//   for (let index = 0; index < items.length; index++) {\n//     if (items[index].name.indexOf(search) !== -1) {\n//       items[index].name = items[index].name.replace(search, replace);\n//       count++;\n//     }\n//   }\n//   return count;\n// }\n\n// export function renameSelectedLayers(search: string, replace: string): number {\n//   var count = 0;\n//   var items = currentDocument().selection;\n//   for (let index = 0; index < items.length; index++) {\n//     if (\n//       items[index].name.indexOf(search) !== -1 &&\n//       items[index].typename === \"Layer\"\n//     ) {\n//       items[index].name = items[index].name.replace(search, replace);\n//       count++;\n//     }\n//   }\n//   return count;\n// }\n\nexport function renameSelectedPaths(\n  search: string,\n  replace: string,\n  fullRename?: boolean\n): number {\n  var count = 0;\n  var items = currentDocument().selection;\n  for (let index = 0; index < items.length; index++) {\n    if (\n      items[index].name.indexOf(search) !== -1 &&\n      items[index].typename !== \"Layer\"\n    ) {\n      fullRename\n        ? (items[index].name = replace)\n        : (items[index].name = items[index].name.replace(search, replace));\n      count++;\n    }\n  }\n  return count;\n}\n\nexport function addRegistration(\n  layerName: string,\n  unit: string,\n  diameter: number,\n  edgeOffset: number,\n  marksPrimary: boolean,\n  marksOrientation: boolean,\n  marksOrientationLocation: string,\n  marksCenter: boolean,\n  marksDistance: boolean,\n  marksDistanceValue: number\n) {\n  try {\n    const doc = currentDocument();\n    const docWidth = doc.width;\n    const docHeight = doc.height;\n    const colorRegistration = createColorCMYK(0, 0, 0, 100);\n    const layer = getLayerByName(layerName) || createLayer(layerName);\n    const diameterPoints = convertToPoints(diameter, unit as UnitName);\n    const halfDiameter = diameterPoints / 2;\n    const edgeOffsetPoints = convertToPoints(edgeOffset, unit as UnitName);\n    const marksDistancePoints = convertToPoints(\n      marksDistanceValue,\n      unit as UnitName\n    );\n\n    doc.rulerOrigin = [0, 0];\n\n    var coordinates: number[][] = [];\n\n    if (marksPrimary) {\n      const coordinatesPrimary: number[][] = [\n        // [ Y, X ]\n        [edgeOffsetPoints + halfDiameter, edgeOffsetPoints - halfDiameter], // Bottom Left\n        [\n          docHeight - edgeOffsetPoints + halfDiameter,\n          edgeOffsetPoints - halfDiameter,\n        ], // Top Left\n        [\n          edgeOffsetPoints + halfDiameter,\n          docWidth - edgeOffsetPoints - halfDiameter,\n        ], // Bottom Right\n        [\n          docHeight - edgeOffsetPoints + halfDiameter,\n          docWidth - edgeOffsetPoints - halfDiameter,\n        ], // Top Right\n      ];\n      coordinates.push(...coordinatesPrimary);\n    }\n\n    if (marksOrientation) {\n      const coordinatesOrientation: number[][] = [];\n      const gap = 144;\n      switch (marksOrientationLocation) {\n        case \"bottom-left\":\n          coordinatesOrientation.push([\n            edgeOffsetPoints + halfDiameter + gap,\n            edgeOffsetPoints - halfDiameter,\n          ]);\n          coordinatesOrientation.push([\n            edgeOffsetPoints + halfDiameter,\n            edgeOffsetPoints - halfDiameter + gap,\n          ]);\n          break;\n        case \"bottom-right\":\n          coordinatesOrientation.push([\n            edgeOffsetPoints + halfDiameter + gap,\n            docWidth - edgeOffsetPoints - halfDiameter,\n          ]);\n          coordinatesOrientation.push([\n            edgeOffsetPoints + halfDiameter,\n            docWidth - edgeOffsetPoints - halfDiameter - gap,\n          ]);\n          break;\n        case \"top-right\":\n          coordinatesOrientation.push([\n            docHeight - edgeOffsetPoints + halfDiameter - gap,\n            docWidth - edgeOffsetPoints - halfDiameter,\n          ]);\n          coordinatesOrientation.push([\n            docHeight - edgeOffsetPoints + halfDiameter,\n            docWidth - edgeOffsetPoints - halfDiameter - gap,\n          ]);\n          break;\n        case \"top-left\":\n        default:\n          coordinatesOrientation.push([\n            docHeight - edgeOffsetPoints + halfDiameter - gap,\n            edgeOffsetPoints - halfDiameter,\n          ]);\n          coordinatesOrientation.push([\n            docHeight - edgeOffsetPoints + halfDiameter,\n            edgeOffsetPoints - halfDiameter + gap,\n          ]);\n          break;\n      }\n\n      coordinates.push(...coordinatesOrientation);\n    }\n\n    if (marksCenter) {\n      const coordinatesCenter: number[][] = [\n        [\n          docHeight - edgeOffsetPoints + halfDiameter,\n          docWidth / 2 - halfDiameter,\n        ], // Top Edge\n        [edgeOffsetPoints + halfDiameter, docWidth / 2 - halfDiameter], // Bottom Edge\n        [docHeight / 2 + halfDiameter, edgeOffsetPoints - halfDiameter], // Left Edge\n        [\n          docHeight / 2 + halfDiameter,\n          docWidth - edgeOffsetPoints - halfDiameter,\n        ], // Right Edge\n      ];\n      coordinates.push(...coordinatesCenter);\n    }\n\n    if (marksDistance) {\n      const coordinatesDistance: number[][] = [];\n\n      // Bottom Row\n      // Initial Coordinates (Bottom Left)\n      var coordY = edgeOffsetPoints + halfDiameter;\n      var coordX = edgeOffsetPoints - halfDiameter + marksDistancePoints;\n      while (coordX < docWidth - edgeOffsetPoints - halfDiameter) {\n        coordinatesDistance.push([coordY, coordX]);\n        coordX += marksDistancePoints;\n      }\n\n      // Top Row\n      // Initial Coordinates (Top Left)\n      coordY = docHeight - edgeOffsetPoints + halfDiameter;\n      coordX = edgeOffsetPoints - halfDiameter + marksDistancePoints;\n      while (coordX < docWidth - edgeOffsetPoints - halfDiameter) {\n        coordinatesDistance.push([coordY, coordX]);\n        coordX += marksDistancePoints;\n      }\n\n      // Left Column\n      // Initial Coordinates (Bottom Left)\n      coordY = edgeOffsetPoints + halfDiameter + marksDistancePoints;\n      coordX = edgeOffsetPoints - halfDiameter;\n      while (coordY < docHeight - edgeOffsetPoints - halfDiameter) {\n        coordinatesDistance.push([coordY, coordX]);\n        coordY += marksDistancePoints;\n      }\n\n      // Right Column\n      // Initial Coordinates (Bottom Right)\n      coordY = edgeOffsetPoints + halfDiameter + marksDistancePoints;\n      coordX = docWidth - edgeOffsetPoints - halfDiameter;\n      while (coordY < docHeight - edgeOffsetPoints - halfDiameter) {\n        coordinatesDistance.push([coordY, coordX]);\n        coordY += marksDistancePoints;\n      }\n\n      coordinates.push(...coordinatesDistance);\n    }\n\n    // Draw each Ellipse from Coordinates\n    for (let index = 0; index < coordinates.length; index++) {\n      const y = coordinates[index][0];\n      const x = coordinates[index][1];\n      drawEllipse(layer, y, x, diameterPoints, colorRegistration);\n    }\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as ilst from \"./ilst/ilst\";\n\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\n\n// A safe way to get the app name since some versions of Adobe Apps broken BridgeTalk in various places (e.g. After Effects 24-25)\n// in that case we have to do various checks per app to deterimine the app name\n\nconst getAppNameSafely = (): ApplicationName | \"unknown\" => {\n  const compare = (a: string, b: string) => {\n    return a.toLowerCase().indexOf(b.toLowerCase()) > -1;\n  };\n  const exists = (a: any) => typeof a !== \"undefined\";\n  const isBridgeTalkWorking =\n    typeof BridgeTalk !== \"undefined\" &&\n    typeof BridgeTalk.appName !== \"undefined\";\n\n  if (isBridgeTalkWorking) {\n    return BridgeTalk.appName;\n  } else if (app) {\n    //@ts-ignore\n    if (exists(app.name)) {\n      //@ts-ignore\n      const name: string = app.name;\n      if (compare(name, \"photoshop\")) return \"photoshop\";\n      if (compare(name, \"illustrator\")) return \"illustrator\";\n      if (compare(name, \"audition\")) return \"audition\";\n      if (compare(name, \"bridge\")) return \"bridge\";\n      if (compare(name, \"indesign\")) return \"indesign\";\n    }\n    //@ts-ignore\n    if (exists(app.appName)) {\n      //@ts-ignore\n      const appName: string = app.appName;\n      if (compare(appName, \"after effects\")) return \"aftereffects\";\n      if (compare(appName, \"animate\")) return \"animate\";\n    }\n    //@ts-ignore\n    if (exists(app.path)) {\n      //@ts-ignore\n      const path = app.path;\n      if (compare(path, \"premiere\")) return \"premierepro\";\n    }\n    //@ts-ignore\n    if (exists(app.getEncoderHost) && exists(AMEFrontendEvent)) {\n      return \"ame\";\n    }\n  }\n  return \"unknown\";\n};\n\nswitch (getAppNameSafely()) {\n  case \"illustrator\":\n  case \"illustratorbeta\":\n    host[ns] = ilst;\n    break;\n}\n\nexport type Scripts = typeof ilst\n\n// https://extendscript.docsforadobe.dev/interapplication-communication/bridgetalk-class.html?highlight=bridgetalk#appname\ntype ApplicationName =\n  | \"aftereffects\"\n  | \"aftereffectsbeta\"\n  | \"ame\"\n  | \"amebeta\"\n  | \"audition\"\n  | \"auditionbeta\"\n  | \"animate\"\n  | \"animatebeta\"\n  | \"bridge\"\n  | \"bridgebeta\"\n  // | \"flash\"\n  | \"illustrator\"\n  | \"illustratorbeta\"\n  | \"indesign\"\n  | \"indesignbeta\"\n  // | \"indesignserver\"\n  | \"photoshop\"\n  | \"photoshopbeta\"\n  | \"premierepro\"\n  | \"premiereprobeta\";\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","minWidth","minHeight","maxWidth","maxHeight","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyZipAssets","unitValue","app","fillColor","strokeColor","strokeWidth","layer","count","items","fullRename","doc","coordinatesOrientation","coordX","coordY","host"],"mappings":";;AAGA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAAUC;AAAcV;AAAsB;AAC9CW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEAC;AAEIC;AACAd;AACAe;AACAC;AACF;AAEFC;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEFQ;;AAEAC;AACF;;AClDA;;ACDA;;AAEA;AACA;;AAEA;AAEA;AACE;AACF;AAEA;AACE;AACF;AAEA;AACE;AACF;AAEA;AACE;AACAC;;AAEF;AAEA;AACEC;AACF;AAEA;AACEA;AACF;AAEA;AAME;;;;;AAKA;AACF;AAEA;;;AAGE;AACF;AAEA;AACE;AACA;AACE;AACA;AACE;AACF;AACF;AACF;AAEA;AASE;AACAC;AACAC;AACAC;AACA;AACF;AAEA;;AAEE;AACA;AACE;;AAEEC;AACAC;AACF;AACF;AACA;AACF;AAEA;;AAEE;AACA;AACE;AACEC;AACAD;AACF;AACF;AACA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAME;AACA;;AAKIE;AAGAF;AACF;AACF;AACA;AACF;AAEA;;AAaI;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAKAG;;AAIA;AACE;AACE;AACA;AAAoE;;AAIjE;;AAIA;AACH;;;AAMJ;AAEA;;;AAGE;AACE;AACEC;AAIAA;AAIA;AACF;AACEA;AAIAA;AAIA;AACF;AACEA;AAIAA;AAIA;AACF;AACA;AACEA;AAIAA;AAIA;AACJ;;AAGF;AAEA;AACE;AAIK;;AAC6D;;AACC;AACjE;;;AAMJ;AAEA;;;AAGE;AACA;AACA;AACA;AACA;;AAEEC;AACF;;AAEA;AACA;AACAC;AACAD;AACA;;AAEEA;AACF;;AAEA;AACA;AACAC;;AAEA;;AAEEA;AACF;;AAEA;AACA;AACAA;AACAD;AACA;;AAEEC;AACF;;AAGF;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACF;AACF;;;;;;;;;;;;;;;;;;;;;;ACzTA;;AAEA;AACA;;AAEA;;AAEI;;AAEF;;AAAmD;AACnD;AAIA;;;AAGE;AACA;AACE;AACA;;;;;;AAMF;AACA;AACA;AACE;AACA;;;AAGF;AACA;AACA;AACE;AACA;;AAEF;AACA;;AAEE;AACF;AACF;AACA;AACF;AAEA;AACE;AACA;AACEC;AACA;AACJ;;AAIA"}